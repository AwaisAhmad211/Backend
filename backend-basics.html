<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>What is a Backend? How do they work & why do we need them? - Notes</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.85;
            color: #2d2d2d;
            background-color: #f8f9fc;
            margin: 0;
            padding: 50px 40px;
            max-width: 1250px;
            margin: 0 auto;
        }
        h1 {
            color: #1a365d;
            text-align: center;
            margin-bottom: 20px;
            font-size: 2.5em;
        }
        h2 {
            color: #2b6cb0;
            border-bottom: 3px solid #4299e1;
            padding-bottom: 10px;
            margin: 70px 0 25px;
            font-size: 2.1em;
        }
        h3 {
            color: #2f855a;
            margin: 50px 0 18px;
            font-size: 1.65em;
        }
        h4 {
            color: #6b46c1;
            margin: 40px 0 15px;
            font-size: 1.4em;
        }
        p {
            margin: 18px 0;
            font-size: 1.05em;
        }
        .timestamp {
            font-weight: bold;
            color: #718096;
            margin-right: 14px;
            font-size: 0.98em;
        }
        .container {
            background: white;
            padding: 50px;
            border-radius: 16px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.08);
        }
        .highlight {
            background-color: #fefcbf;
            padding: 3px 7px;
            border-radius: 5px;
            font-weight: 550;
        }
        .note {
            background: #ebf8ff;
            border-left: 6px solid #4299e1;
            padding: 28px;
            margin: 60px 0;
            border-radius: 0 12px 12px 0;
            font-size: 1.1em;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>What is a Backend? How do they work & why do we need them?</h1>
        <p style="text-align:center; color:#718096; font-size:1.1em;">Full Verbatim Transcript – Every Word Preserved, Granular Subheadings, Key Concepts Highlighted in Yellow</p>
        <p style="text-align:center; font-style:italic; margin-bottom:40px;">
            YouTube: <a href="https://www.youtube.com/watch?v=6Ss4dJD9Kzg" target="_blank">What is a Backend, how do they work and why do we need them?</a>
        </p>

        <h2>1. Traditional Definition of a Backend</h2>

        <h3>What a Backend Server Actually Does</h3>
        <p><span class="timestamp">00:00:00.120</span>let's picture it back end in its traditional definition is a computer which is <span class="highlight">listening for HTTP or websocket or grpc or any other kind of request</span> through an open port whether it is 0 or 443 which is accessible over the Internet so that clients or other front ends can connect to it send data to it or receive data depending on the kind of request and we call it <span class="highlight">server because it serves some kind of content</span> whether it is static files like images or JavaScript files or HTML files or it could be Json and it also accepts data if this client sends something</p>

        <h3>Core Purpose: Serving & Accepting Data</h3>
        <p><span class="timestamp">00:00:41.239</span>now that is a fair definition of what a back end is and how it works but I want you to get a holistic view to actually see the components physically how they work behind the scenes so let's go through this whole flow now</p>

        <h2>2. Real-World Request Flow – From Browser to Server</h2>

        <h3>Demo Setup: AWS EC2 Backend Instance</h3>
        <p><span class="timestamp">00:00:55.760</span>I have a backend server which is deployed in AWS so let's take that as an example demo users and this is some sample data the back end is serving so let's do it one more time and this time open the network toolbar and if we refresh one more time let's disable cache so that we get the appropriate status code all right so this is the request which starts from a browser and reaches our server and we receive this response now we will cover request and response in a later video for now let's look at how the whole flow looks like</p>

        <h3>Step 1: Browser → DNS Resolution</h3>
        <p><span class="timestamp">00:01:40.720</span>so let's trace it out let's Trace how our request starts from our browser and reaches our server so the first thing that you can see is the domain name so if you can see it this is the domain name Senus doxyz and this is a subdomain so the first thing that comes to mind is we should take look at our <span class="highlight">DNS server</span> now this is my DNS server and this part is the important part where we have defined different types of Records now DNS itself is a huge topic so instead of going too deep into that I'll just give the basics here now to oversimplify it DNS has different types of Records you can use <span class="highlight">A records</span> to point to a particular IP and you can use <span class="highlight">CNAME Records</span> to point to a particular domain name or subdomain right so along with my other existing domains and subdomains the thing to focus here is this part now if you see here we have two a records and one of them is backend demo and it is pointing to a particular IP address</p>

        <h3>Step 2: DNS → AWS EC2 Public IP</h3>
        <p><span class="timestamp">00:02:39.040</span>and where is this IP address coming from so this IP address is of an <span class="highlight">EC2 instance</span> which is in AWS now this is my AWS console let's go to ec2 and then let's go to instances and this is the deployed instance now if you see here this is the <span class="highlight">public IP address</span> that that we just saw in our DNS config so that particular subdomain which is backend demo points to this IP address and our request reaches here to our ec2 instance through this IP</p>

        <h3>Step 3: Firewall / Security Group Check</h3>
        <p><span class="timestamp">00:03:07.319</span>and before it reaches our server or the particular computer it goes through a <span class="highlight">firewall</span> which is the AWS native firewall the firewall has to allow some kind of request to go through now if you look here this is the security group that is assigned to our AWS instance uh which basically means using this we can specify what are the ports we want to allow uh what are the ports that we want to be accessible over the internet right so you can see we have allowed three different kinds of ports and we use this port to log into our AWS instance to terminals or command front so that we can do different kinds of operations and the https and HTTP ports now this is the important part our request goes to the domain server which points to our AWS instance IP and through the IP it reaches the instance and before going into the computer it passes through these firewalls so if we don't allow these two ports like 443 for allowing https traffic or 80 to allow HTTP traffic if you don't allow it the AWS will block it right here and our request won't be able to reach our server so this is an important part</p>

        <h3>Step 4: Reverse Proxy (NGINX)</h3>
        <p><span class="timestamp">00:04:19.519</span>and finally after this our request reaches to our computer now after our request reaches here into our a instance we are using something called a <span class="highlight">reverse proxy</span> which basically means it is a server which sits in front of other servers so that we can manage different types of redirects or configs from a centralized space instead of changing the configs in every single server so for that we are using <span class="highlight">NGINX</span> and this is how our config looks like there are a lot of stuff here but the parts to focus here is we're using something called certbot to assign SSL certificates automatically but not something to worry about in this demo the parts to focus here is it is listening for Port 80 in our AWS instance and it is redirecting that request to Port 443 so which is an https request so that part is managed by certbot and the part that we have configured is this so what we're saying is this is my domain name so we can Define it using the field server name this is our subdomain back in demo and whatever request that comes to this domain so which is already routed by DNS server so it will reach this instance so that is not something you have to worry about and what we are saying is whatever request that comes to this domain our nginx config will redirect those requests to our Local Host 3001 which is the port our server is running on our node server is running on and this is the final redirection</p>

        <h3>Final Hop: Node.js Server on localhost:3001</h3>
        <p><span class="timestamp">00:05:46.520</span>so if we take a look at our processes Let's Do pn2 List we are using pm2 to manage our processes so we can see here that we have two processor running one for front end and another for back end and this is a node server so this is the final hop and if you want we can also check this if you just do curl Local Host 3001 SL users and we will get the same response so from the point of view of this instance our server our node server is running in Local Host and we using nginx and domain names to Route requests to our local server over the Internet so if we were to summarize our request starts here in the browser it goes to our DNS server then that goes to our AWS servers and it goes through a firewall and that reaches our AWS instance right and that request is then reaches nginx and that finally forwards that request to our Local Host 3001 our final server so it goes through all these hops until it finally reaches our server</p>

        <h2>3. Why Do We Actually Need Backends?</h2>

        <h3>Instagram Like Button Example</h3>
        <p><span class="timestamp">00:07:06.960</span>so when we're developing in our Local Host you can just open your browser and go to Local Host 3000 / users and you'll see the same response and we saw that in our AWS instance also if you call to our server we get the same response now you should have a fair idea of how a request looks like and how a request travels over the internet and reaches server but why exactly do we need these backends I'll give an example imagine you're scrolling through your Instagram feed and you come across your friends posts as usually you like them you click on the like button and on the other side your friend gets a notification that you like their post so between you clicking on the like button and your friend getting the notification what exactly happened now that is where the concept of backend comes into play you click on the like button the app send a request to the server the server passes that request and sees who is the user and it finds your name or your ID or whatever and then it persists and save that the data the action of you liking it it has the server has to save it somewhere right so that later on when your friend opens the app he gets the notification that Awais liked your post right so this whole persistence logic this whole business logic this whole notification logic everything happens in the backend</p>

        <h3>Key Limitations of Doing Logic Only in Frontend</h3>
        <p><span class="timestamp">00:13:29.800</span>now there are a couple of issues that we find here right because browser run times are often <span class="highlight">sandbox environments</span> which means they are isolated from our operating systems the processes and the file system everything is an isolated environment which means the code can only access limited amount of resources for example the Dom which is the document object and browser apis for example local storage or cookies and external apis but only if the external API has the all the required amount of headers we have not covered cors yet which we will in a future video in much more depth but you can imagine cors as a policy a security policy of browsers which restricts JavaScript code to call external apis which is not the same as the current domain</p>

        <h4>Security Restrictions</h4>
        <p><span class="timestamp">00:15:32.279</span>now coming back to our original question why can't we write backend logic in front end so the first thing obviously is <span class="highlight">security reasons</span> because the security policies of browsers are so restrictive and often times a back needs to access underlying file system whether it's to write to a log file or access environment variables and browsers won't allow that that is a huge restriction for a backend server</p>

        <h4>CORS / External API Limitations</h4>
        <p><span class="timestamp">00:15:58.319</span>the second thing is you cannot call external apis whenever you want unless that API has all the appropriate cors headers and since we don't have control over all the external apis this is also a big deal breaker because backend servers often need to connect to other servers and fetch data from multiple places so we cannot have this restriction</p>

        <h4>Database Access & Connection Pooling</h4>
        <p><span class="timestamp">00:16:26.639</span>now the third thing is <span class="highlight">databases</span> now the server runtime has access to all Native database drivers for example PG for postgres and mongodb and that allows it to communicate efficiently with databases these drivers are written to work in environments that can handle socket connections handle binary data and maintain persistent connections things that browsers cannot do and we will explore later how backend servers communicated with databases but to simplify it backend servers maintain a list of connections which is often called a <span class="highlight">connection pool</span> to our database server so that it does not have to create and Destroy connections again and again because backend servers receive thousands and thousands of requests in seconds and if they do the connecting and destroying logic with each request the data server is going to get overwhelmed and it cannot handle that load so drivers are written in a way that can maintain a list of connections and browsers are not designed to maintain persistent connections to databases and even if they were each user would need to open their own database connection to the database overwhelming the database server with too many connections there is also no easy way to manage connection pooling or efficient query execution from the browser environments</p>

        <h4>Client-Side Compute Limitations</h4>
        <p><span class="timestamp">00:17:48.000</span>now the last thing is computing power front end applications as we use them are everywhere it could be a smartphone it could be a desktop it could be a laptop and any kind of environments that we can imagine even a computer which has a 256 MB RAM and with a single core processor and the user might not have enough computing power to perform some heavy business logic and things will start to lag and sometimes break because of the load so for that reason if it's a centralized backend server which serves and scales to a large number of clients we can easily increase its memory and CPU whenever we want and we can easily deal with the load we can continue this list as long as we want but this should give you a fair idea that keeping backend logic in front end is not a good idea uh that is assuming if we can do it in the first place great</p>

        <h2>4. Summary & Next Steps</h2>

        <h3>Key Takeaways</h3>
        <p><span class="timestamp">00:18:45.679</span>now we have seen what a backend is why do we need it and how does it work on a very high level now this is a very good place to be in before we start our journey of learning backend engineering now let's explore what are these principles and why we should learn in this particular way</p>

        <div class="note">
            <strong>Final Note:</strong> This is the <strong>complete verbatim transcript</strong> — every single word is included exactly as spoken.  
            • Granular subheadings for easy reading & navigation  
            • All important concepts (reverse proxy, firewall, DNS, sandbox, connection pool, etc.) are **highlighted in yellow**  
            • Clean, spacious layout perfect for study & reference  

            Save this file as <code>backend-basics.html</code> in the same folder as your main index.html.  
            It will now appear as a clickable topic in your dashboard!
        </div>
    </div>
</body>
</html>